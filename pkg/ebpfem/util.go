//go:build linux && amd64
// +build linux,amd64

/*
* This file is part of Celestial (https://github.com/OpenFogStack/celestial).
* Copyright (c) 2024 Soeren Becker, Nils Japke, Tobias Pfandzelter, The
* OpenFogStack Team.
*
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, version 3.
*
* This program is distributed in the hope that it will be useful, but
* WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
* General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program. If not, see <http://www.gnu.org/licenses/>.
**/

package ebpfem

//Adapted from: https://github.com/srnbckr/ebpf-network-emulation/blob/main/internal/utils/tc_helpers.go

import (
	"bytes"
	"encoding/binary"
	"net"

	"github.com/pkg/errors"
	log "github.com/sirupsen/logrus"
	"github.com/vishvananda/netlink"
	"golang.org/x/sys/unix"
)

func incrementIP(ip net.IP) {
	for j := len(ip) - 1; j >= 0; j-- {
		ip[j]++
		if ip[j] > 0 {
			break
		}
	}
}

func parseIPToLong(ip net.IP) (uint32, error) {
	var l uint32
	err := binary.Read(bytes.NewBuffer(ip.To4()), binary.LittleEndian, &l)
	if err != nil {
		return 0, errors.Wrap(err, "cannot convert IP to uint32")
	}
	return l, nil
}

// parseNetToLongs parses IP address from net.IP into []uint32 (with reversed order), returning all
// IPs in the subnet. We need these as keys in our eBPF map.
func parseNetToLongs(target net.IPNet) ([]uint32, error) {
	var longs []uint32

	// Get the start and end IP addresses in the subnet
	startIP := target.IP.Mask(target.Mask)
	endIP := make(net.IP, len(startIP))
	copy(endIP, startIP)

	// Magic generated by ChatGPT
	for i := range endIP {
		endIP[i] |= ^target.Mask[i]
	}

	// Iterate through all IP addresses in the subnet and add them to the slice
	for ip := startIP; !ip.Equal(endIP); incrementIP(ip) {
		l, err := parseIPToLong(ip)
		if err != nil {
			return nil, errors.Wrap(err, "cannot convert IP to uint32")
		}
		longs = append(longs, l)
		//log.Tracef("Added IP %s as long %d", ip.String(), l)
	}

	// Add the last IP address in the subnet
	l, err := parseIPToLong(endIP)
	if err != nil {
		return nil, errors.Wrap(err, "cannot convert IP to uint32")
	}

	longs = append(longs, l)
	//log.Tracef("Added IP %s as long %d", endIP.String(), l)

	return longs, nil
}

func getIface(name string) (netlink.Link, error) {
	iface, err := netlink.LinkByName(name)
	if err != nil {
		return nil, errors.Wrapf(err, "cannot find %s", name)
	}
	return iface, nil
}

// CreateClsactQdisc creates clsact qdisc. This is necessary for the tc egress hook. The packets are forwarded to net.c.
// The eBPF-program adjusts the departure time of the packets based on the values in the eBPF-map.
func createClsactQdisc(iface netlink.Link) (*netlink.GenericQdisc, error) {
	attrs := netlink.QdiscAttrs{
		LinkIndex: iface.Attrs().Index,
		Handle:    netlink.MakeHandle(0xffff, 0),
		Parent:    netlink.HANDLE_CLSACT,
	}

	qdisc := &netlink.GenericQdisc{
		QdiscAttrs: attrs,
		QdiscType:  "clsact",
	}

	if err := netlink.QdiscAdd(qdisc); err != nil {
		return nil, errors.Wrap(err, "Cannot add clsact qdisc")
	}
	log.Tracef("Added clsact qdisc %v", qdisc)
	return qdisc, nil
}

/*
Creates fq qdisc which uses a timing wheel and then releases the packets to the network interface based on their
time stamp.
*/
func createFQdisc(iface netlink.Link) (*netlink.Fq, error) {
	//tc qdisc add dev wlp2s0 root fq ce_threshold 4ms
	attrs := netlink.QdiscAttrs{
		LinkIndex: iface.Attrs().Index,
		Handle:    netlink.MakeHandle(0x123, 0),
		Parent:    netlink.HANDLE_ROOT,
	}

	fq := &netlink.Fq{
		QdiscAttrs: attrs,
		Pacing:     0,
	}

	if err := netlink.QdiscAdd(fq); err != nil {
		return nil, errors.Wrap(err, "Cannot add fq qdisc")
	}
	log.Tracef("Added fq qdisc %v", fq)
	return fq, nil
}

func createTCBpfFilter(iface netlink.Link, progFd int, parent uint32, name string) (*netlink.BpfFilter, error) {
	filterAttrs := netlink.FilterAttrs{
		LinkIndex: iface.Attrs().Index,
		Parent:    parent,
		Handle:    netlink.MakeHandle(0, 1),
		Protocol:  unix.ETH_P_ALL,
		Priority:  1,
	}

	filter := &netlink.BpfFilter{
		FilterAttrs:  filterAttrs,
		Fd:           progFd,
		Name:         name,
		DirectAction: true,
	}

	if err := netlink.FilterAdd(filter); err != nil {
		return nil, errors.Wrap(err, "Cannot attach bpf object to filter")
	}

	log.Tracef("Created bpf filter: %v", filter)
	return filter, nil
}
